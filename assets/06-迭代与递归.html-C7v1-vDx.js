import{_ as l,c as t,o as e,d as n,a as s,b as a}from"./app-C4v31drI.js";const m="/assets/iteration-C8Q9Z7oD.png",i="/assets/nested_iteration-BDedR65p.png",c="/assets/recursion_sum-Bzf7mZaV.png",r="/assets/recursion_sum_depth-Dl-tuK-_.png",p="/assets/tail_recursion_sum-DsUvXX9-.png",o="/assets/recursion_tree-CfGTUnBS.png",h={},g=n('<h1 id="迭代与递归" tabindex="-1"><a class="header-anchor" href="#迭代与递归"><span>迭代与递归</span></a></h1><p>在算法中，重复执行某个任务是很常见的，它与复杂度分析息息相关。因此，在介绍时间复杂度和空间复杂度之前，我们先来了解如何在程序中实现重复执行任务，即两种基本的程序控制结构：迭代、递归。</p><h2 id="迭代" tabindex="-1"><a class="header-anchor" href="#迭代"><span>迭代</span></a></h2><p><u>迭代（iteration）</u>是一种重复执行某个任务的控制结构。在迭代中，程序会在满足一定的条件下重复执行某段代码，直到这个条件不再满足。</p><h3 id="for-循环" tabindex="-1"><a class="header-anchor" href="#for-循环"><span>for 循环</span></a></h3><p><code>for</code> 循环是最常见的迭代形式之一，<strong>适合在预先知道迭代次数时使用</strong>。</p>',6),u=s("p",null,[a("以下函数基于 "),s("code",null,"for"),a(" 循环实现了求和 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"1"),s("mo",null,"+"),s("mn",null,"2"),s("mo",null,"+"),s("mo",null,"⋯"),s("mo",null,"+"),s("mi",null,"n")]),s("annotation",{encoding:"application/x-tex"},"1 + 2 + \\dots + n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},"2"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),s("span",{class:"minner"},"⋯"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"n")])])]),a(" ，求和结果使用变量 "),s("code",null,"res"),a(" 记录。需要注意的是，Python 中 "),s("code",null,"range(a, b)"),a(" 对应的区间是“左闭右开”的，对应的遍历范围为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"a"),s("mo",{separator:"true"},","),s("mi",null,"a"),s("mo",null,"+"),s("mn",null,"1"),s("mo",{separator:"true"},","),s("mo",null,"…"),s("mo",{separator:"true"},","),s("mi",null,"b"),s("mo",null,"−"),s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"a, a + 1, \\dots, b-1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7778em","vertical-align":"-0.1944em"}}),s("span",{class:"mord mathnormal"},"a"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal"},"a"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8889em","vertical-align":"-0.1944em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"minner"},"…"),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal"},"b"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])]),a(" ：")],-1),d=n(`<div class="language-src line-numbers-mode" data-ext="src" data-title="src"><pre class="language-src"><code>[file]{iteration}-[class]{}-[func]{for_loop}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>下图是该求和函数的流程框图。</p><figure><img src="`+m+'" alt="求和函数的流程框图" tabindex="0" loading="lazy"><figcaption>求和函数的流程框图</figcaption></figure>',3),x=s("p",null,[a("此求和函数的操作数量与输入数据大小 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"n")]),s("annotation",{encoding:"application/x-tex"},"n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"n")])])]),a(" 成正比，或者说成“线性关系”。实际上，"),s("strong",null,"时间复杂度描述的就是这个“线性关系”"),a("。相关内容将会在下一节中详细介绍。")],-1),y=s("h3",{id:"while-循环",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#while-循环"},[s("span",null,"while 循环")])],-1),w=s("p",null,[a("与 "),s("code",null,"for"),a(" 循环类似，"),s("code",null,"while"),a(" 循环也是一种实现迭代的方法。在 "),s("code",null,"while"),a(" 循环中，程序每轮都会先检查条件，如果条件为真，则继续执行，否则就结束循环。")],-1),b=s("p",null,[a("下面我们用 "),s("code",null,"while"),a(" 循环来实现求和 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"1"),s("mo",null,"+"),s("mn",null,"2"),s("mo",null,"+"),s("mo",null,"⋯"),s("mo",null,"+"),s("mi",null,"n")]),s("annotation",{encoding:"application/x-tex"},"1 + 2 + \\dots + n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},"2"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),s("span",{class:"minner"},"⋯"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"n")])])]),a(" ：")],-1),f=s("div",{class:"language-src line-numbers-mode","data-ext":"src","data-title":"src"},[s("pre",{class:"language-src"},[s("code",null,`[file]{iteration}-[class]{}-[func]{while_loop}
`)]),s("div",{class:"line-numbers","aria-hidden":"true"},[s("div",{class:"line-number"})])],-1),_=s("p",null,[s("strong",null,[s("code",null,"while"),a(" 循环比 "),s("code",null,"for"),a(" 循环的自由度更高")]),a("。在 "),s("code",null,"while"),a(" 循环中，我们可以自由地设计条件变量的初始化和更新步骤。")],-1),k=s("p",null,[a("例如在以下代码中，条件变量 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"i")]),s("annotation",{encoding:"application/x-tex"},"i")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6595em"}}),s("span",{class:"mord mathnormal"},"i")])])]),a(" 每轮进行两次更新，这种情况就不太方便用 "),s("code",null,"for"),a(" 循环实现：")],-1),v=n(`<div class="language-src line-numbers-mode" data-ext="src" data-title="src"><pre class="language-src"><code>[file]{iteration}-[class]{}-[func]{while_loop_ii}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>总的来说，<strong><code>for</code> 循环的代码更加紧凑，<code>while</code> 循环更加灵活</strong>，两者都可以实现迭代结构。选择使用哪一个应该根据特定问题的需求来决定。</p><h3 id="嵌套循环" tabindex="-1"><a class="header-anchor" href="#嵌套循环"><span>嵌套循环</span></a></h3><p>我们可以在一个循环结构内嵌套另一个循环结构，下面以 <code>for</code> 循环为例：</p><div class="language-src line-numbers-mode" data-ext="src" data-title="src"><pre class="language-src"><code>[file]{iteration}-[class]{}-[func]{nested_for_loop}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>下图是该嵌套循环的流程框图。</p><figure><img src="`+i+'" alt="嵌套循环的流程框图" tabindex="0" loading="lazy"><figcaption>嵌套循环的流程框图</figcaption></figure>',7),M=s("p",null,[a("在这种情况下，函数的操作数量与 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mi",null,"n"),s("mn",null,"2")])]),s("annotation",{encoding:"application/x-tex"},"n^2")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8141em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8141em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])])])])])])])])]),a(" 成正比，或者说算法运行时间和输入数据大小 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"n")]),s("annotation",{encoding:"application/x-tex"},"n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"n")])])]),a(" 成“平方关系”。")],-1),L=n('<p>我们可以继续添加嵌套循环，每一次嵌套都是一次“升维”，将会使时间复杂度提高至“立方关系”“四次方关系”，以此类推。</p><h2 id="递归" tabindex="-1"><a class="header-anchor" href="#递归"><span>递归</span></a></h2><p><u>递归（recursion）</u>是一种算法策略，通过函数调用自身来解决问题。它主要包含两个阶段。</p><ol><li><strong>递</strong>：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。</li><li><strong>归</strong>：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。</li></ol><p>而从实现的角度看，递归代码主要包含三个要素。</p><ol><li><strong>终止条件</strong>：用于决定什么时候<em>由“递”转“归”</em>。</li><li><strong>递归调用</strong>：对应“递”，函数调用自身，通常输入更小或更简化的参数。</li><li><strong>返回结果</strong>：对应“归”，将当前递归层级的结果返回至上一层。</li></ol>',6),E=s("p",null,[a("观察以下代码，我们只需调用函数 "),s("code",null,"recur(n)"),a(" ，就可以完成 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"1"),s("mo",null,"+"),s("mn",null,"2"),s("mo",null,"+"),s("mo",null,"⋯"),s("mo",null,"+"),s("mi",null,"n")]),s("annotation",{encoding:"application/x-tex"},"1 + 2 + \\dots + n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},"2"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),s("span",{class:"minner"},"⋯"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"n")])])]),a(" 的计算：")],-1),B=n(`<div class="language-src line-numbers-mode" data-ext="src" data-title="src"><pre class="language-src"><code>[file]{recursion}-[class]{}-[func]{recur}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>下图展示了该函数的递归过程。</p><figure><img src="`+c+'" alt="求和函数的递归过程" tabindex="0" loading="lazy"><figcaption>求和函数的递归过程</figcaption></figure><p>虽然从计算角度看，迭代与递归可以得到相同的结果，<strong>但它们代表了两种完全不同的思考和解决问题的范式</strong>。</p><ul><li><strong>迭代</strong>：“自下而上”地解决问题。从最基础的步骤开始，然后不断重复或累加这些步骤，直到任务完成。</li><li><strong>递归</strong>：“自上而下”地解决问题。将原问题分解为更小的子问题，这些子问题和原问题具有相同的形式。接下来将子问题继续分解为更小的子问题，直到基本情况时停止（基本情况的解是已知的）。</li></ul>',5),z=s("p",null,[a("以上述求和函数为例，设问题 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"f"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",{stretchy:"false"},")"),s("mo",null,"="),s("mn",null,"1"),s("mo",null,"+"),s("mn",null,"2"),s("mo",null,"+"),s("mo",null,"⋯"),s("mo",null,"+"),s("mi",null,"n")]),s("annotation",{encoding:"application/x-tex"},"f(n) = 1 + 2 + \\dots + n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.10764em"}},"f"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},"2"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),s("span",{class:"minner"},"⋯"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"n")])])]),a(" 。")],-1),A=s("ul",null,[s("li",null,[s("strong",null,"迭代"),a("：在循环中模拟求和过程，从 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])]),a(" 遍历到 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"n")]),s("annotation",{encoding:"application/x-tex"},"n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"n")])])]),a(" ，每轮执行求和操作，即可求得 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"f"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"f(n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.10764em"}},"f"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),a(" 。")]),s("li",null,[s("strong",null,"递归"),a("：将问题分解为子问题 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"f"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",{stretchy:"false"},")"),s("mo",null,"="),s("mi",null,"n"),s("mo",null,"+"),s("mi",null,"f"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",null,"−"),s("mn",null,"1"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"f(n) = n + f(n-1)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.10764em"}},"f"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.10764em"}},"f"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")")])])]),a(" ，不断（递归地）分解下去，直至基本情况 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"f"),s("mo",{stretchy:"false"},"("),s("mn",null,"1"),s("mo",{stretchy:"false"},")"),s("mo",null,"="),s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"f(1) = 1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.10764em"}},"f"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])]),a(" 时终止。")])],-1),D=n('<h3 id="调用栈" tabindex="-1"><a class="header-anchor" href="#调用栈"><span>调用栈</span></a></h3><p>递归函数每次调用自身时，系统都会为<mark>新开启的函数</mark>分配内存，以<mark>存储局部变量</mark>、<mark>调用地址</mark>和<mark>其他信息</mark>等。这将导致两方面的结果。</p><ul><li>函数的上下文数据都存储在称为“栈帧空间”的内存区域中，直至函数返回后才会被释放。因此，<strong>递归通常比迭代更加耗费内存空间</strong>。</li><li>递归调用函数会产生额外的开销。<strong>因此递归通常比循环的时间效率更低</strong>。</li></ul>',3),T=s("p",null,[a("如下图所示，在触发终止条件前，同时存在 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"n")]),s("annotation",{encoding:"application/x-tex"},"n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"n")])])]),a(" 个未返回的递归函数，"),s("strong",null,[a("递归深度为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"n")]),s("annotation",{encoding:"application/x-tex"},"n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"n")])])])]),a(" 。")],-1),N=n('<figure><img src="'+r+'" alt="递归调用深度" tabindex="0" loading="lazy"><figcaption>递归调用深度</figcaption></figure><p>在实际中，编程语言<u>允许的递归深度通常是有限的</u>，过深的递归可能导致<em>栈溢出</em>错误。</p><h3 id="尾递归" tabindex="-1"><a class="header-anchor" href="#尾递归"><span>尾递归</span></a></h3><p>有趣的是，<strong>如果函数在返回前的最后一步才进行递归调用</strong>，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当。这种情况被称为<u>尾递归（tail recursion）</u>。</p><ul><li><strong>普通递归</strong>：当函数返回到上一层级的函数后，需要继续执行代码，因此系统需要保存上一层调用的上下文。</li><li><strong>尾递归</strong>：递归调用是函数返回前的最后一个操作，这意味着<em>函数返回到上一层级后，无须继续执行其他操作</em>，因此系统<em>无须保存</em>上一层函数的上下文。</li></ul>',5),C=s("p",null,[a("以计算 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"1"),s("mo",null,"+"),s("mn",null,"2"),s("mo",null,"+"),s("mo",null,"⋯"),s("mo",null,"+"),s("mi",null,"n")]),s("annotation",{encoding:"application/x-tex"},"1 + 2 + \\dots + n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},"2"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),s("span",{class:"minner"},"⋯"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"n")])])]),a(" 为例，我们可以将结果变量 "),s("code",null,"res"),a(" 设为函数参数，从而实现尾递归：")],-1),P=n(`<div class="language-src line-numbers-mode" data-ext="src" data-title="src"><pre class="language-src"><code>[file]{recursion}-[class]{}-[func]{tail_recur}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>尾递归的执行过程如下图所示。对比普通递归和尾递归，两者的求和操作的<mark>执行点</mark>是不同的。</p><ul><li><strong>普通递归</strong>：求和操作是在“归”的过程中执行的，每层返回后都要再执行一次求和操作。</li><li><strong>尾递归</strong>：求和操作是在“递”的过程中执行的，“归”的过程只需层层返回。</li></ul><figure><img src="`+p+`" alt="尾递归过程" tabindex="0" loading="lazy"><figcaption>尾递归过程</figcaption></figure><p>!!! tip</p><pre><code>请注意，许多编译器或解释器并不支持尾递归优化。例如，Python 默认不支持尾递归优化，因此即使函数是尾递归形式，仍然可能会遇到栈溢出问题。
</code></pre><h3 id="递归树" tabindex="-1"><a class="header-anchor" href="#递归树"><span>递归树</span></a></h3><p>当处理与“<u>分治</u>”相关的算法问题时，递归往往比迭代的思路更加直观、代码更加易读。以“斐波那契数列”为例。</p><p>!!! question</p><pre><code>给定一个斐波那契数列 $0, 1, 1, 2, 3, 5, 8, 13, \\dots$ ，求该数列的第 $n$ 个数字。
</code></pre>`,10),V=s("p",null,[a("设斐波那契数列的第 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"n")]),s("annotation",{encoding:"application/x-tex"},"n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"n")])])]),a(" 个数字为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"f"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"f(n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.10764em"}},"f"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),a(" ，易得两个结论。")],-1),$=s("ul",null,[s("li",null,[a("数列的前两个数字为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"f"),s("mo",{stretchy:"false"},"("),s("mn",null,"1"),s("mo",{stretchy:"false"},")"),s("mo",null,"="),s("mn",null,"0")]),s("annotation",{encoding:"application/x-tex"},"f(1) = 0")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.10764em"}},"f"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"0")])])]),a(" 和 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"f"),s("mo",{stretchy:"false"},"("),s("mn",null,"2"),s("mo",{stretchy:"false"},")"),s("mo",null,"="),s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"f(2) = 1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.10764em"}},"f"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"2"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])]),a(" 。")]),s("li",null,[a("数列中的每个数字是前两个数字的和，即 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"f"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",{stretchy:"false"},")"),s("mo",null,"="),s("mi",null,"f"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",null,"−"),s("mn",null,"1"),s("mo",{stretchy:"false"},")"),s("mo",null,"+"),s("mi",null,"f"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",null,"−"),s("mn",null,"2"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"f(n) = f(n - 1) + f(n - 2)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.10764em"}},"f"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.10764em"}},"f"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.10764em"}},"f"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"2"),s("span",{class:"mclose"},")")])])]),a(" 。")])],-1),H=s("p",null,[a("按照递推关系进行递归调用，将前两个数字作为终止条件，便可写出递归代码。调用 "),s("code",null,"fib(n)"),a(" 即可得到斐波那契数列的第 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"n")]),s("annotation",{encoding:"application/x-tex"},"n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"n")])])]),a(" 个数字：")],-1),S=s("div",{class:"language-src line-numbers-mode","data-ext":"src","data-title":"src"},[s("pre",{class:"language-src"},[s("code",null,`[file]{recursion}-[class]{}-[func]{fib}
`)]),s("div",{class:"line-numbers","aria-hidden":"true"},[s("div",{class:"line-number"})])],-1),Z=s("p",null,[a("观察以上代码，我们在函数内递归调用了两个函数，"),s("strong",null,"这意味着从一个调用产生了两个调用分支"),a("。如下图所示，这样不断递归调用下去，最终将产生一棵层数为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"n")]),s("annotation",{encoding:"application/x-tex"},"n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"n")])])]),a(" 的"),s("u",null,"递归树（recursion tree）"),a("。")],-1),G=n('<figure><img src="'+o+`" alt="斐波那契数列的递归树" tabindex="0" loading="lazy"><figcaption>斐波那契数列的递归树</figcaption></figure><p>从本质上看，递归体现了“将问题分解为更小子问题”的思维范式，这种分治策略至关重要。</p><ul><li>从<strong>算法</strong>角度看，<em>搜索、排序、回溯、分治、动态规划</em>等许多重要算法策略直接或间接地应用了这种思维方式。</li><li>从<strong>数据结构</strong>角度看，递归天然适合处理<mark>链表</mark>、<mark>树</mark>和<mark>图</mark>的相关问题，因为它们非常适合用分治思想进行分析。</li></ul><h2 id="两者对比" tabindex="-1"><a class="header-anchor" href="#两者对比"><span>两者对比</span></a></h2><p>总结以上内容，如下表所示，迭代和递归在实现、性能和适用性上有所不同。</p><table><thead><tr><th></th><th>迭代</th><th>递归</th></tr></thead><tbody><tr><td>实现方式</td><td>循环结构</td><td>函数调用自身</td></tr><tr><td>时间效率</td><td>效率通常较高，无函数调用开销</td><td>每次函数调用都会产生开销</td></tr><tr><td>内存使用</td><td>通常使用固定大小的内存空间</td><td>累积函数调用可能使用大量的栈帧空间</td></tr><tr><td>适用问题</td><td>适用于简单循环任务，代码直观、可读性好</td><td><u>适用于子问题分解</u>，如树、图、分治、回溯等，代码结构简洁、清晰</td></tr></tbody></table><p>!!! tip</p><pre><code>如果感觉以下内容理解困难，可以在读完“栈”章节后再来复习。
</code></pre><p>那么，迭代和递归具有什么内在联系呢？以上述递归函数为例，求和操作在递归的“归”阶段进行。这意味着最初被调用的函数实际上是最后完成其求和操作的，<strong>这种工作机制与栈的“先入后出”原则异曲同工</strong>。</p><p>事实上，“调用栈”和“栈帧空间”这类递归术语已经暗示了递归与栈之间的密切关系。</p><ol><li><strong>递</strong>：当函数被调用时，系统会在“调用栈”上为该函数分配新的栈帧，用于存储函数的局部变量、参数、返回地址等数据。</li><li><strong>归</strong>：当函数完成执行并返回时，对应的栈帧会被从“调用栈”上移除，恢复之前函数的执行环境。</li></ol><p>因此，<strong>我们可以使用一个显式的栈来模拟调用栈的行为</strong>，从而将递归转化为迭代形式：</p><div class="language-src line-numbers-mode" data-ext="src" data-title="src"><pre class="language-src"><code>[file]{recursion}-[class]{}-[func]{for_loop_recur}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>观察以上代码，当递归转化为迭代后，代码变得更加复杂了。尽管迭代和递归在很多情况下可以互相转化，<em>但不一定值得这样做</em>，有以下两点原因。</p><ul><li>转化后的代码可能更加难以理解，可读性更差。</li><li>对于某些复杂问题，模拟系统调用栈的行为可能非常困难。</li></ul><p>总之，<strong>选择迭代还是递归取决于特定问题的性质</strong>。在编程实践中，权衡两者的优劣并根据情境选择合适的方法至关重要。</p>`,16),O=[g,u,d,x,y,w,b,f,_,k,v,M,L,E,B,z,A,D,T,N,C,P,V,$,H,S,Z,G];function R(U,X){return e(),t("div",null,O)}const F=l(h,[["render",R],["__file","06-迭代与递归.html.vue"]]),J=JSON.parse('{"path":"/HelloAlgo/%E7%AC%AC02%E7%AB%A0%20%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/06-%E8%BF%AD%E4%BB%A3%E4%B8%8E%E9%80%92%E5%BD%92.html","title":"迭代与递归","lang":"zh-CN","frontmatter":{"date":"2024-05-16T00:00:00.000Z","shortTitle":"06-迭代与递归"},"headers":[{"level":2,"title":"迭代","slug":"迭代","link":"#迭代","children":[{"level":3,"title":"for 循环","slug":"for-循环","link":"#for-循环","children":[]},{"level":3,"title":"while 循环","slug":"while-循环","link":"#while-循环","children":[]},{"level":3,"title":"嵌套循环","slug":"嵌套循环","link":"#嵌套循环","children":[]}]},{"level":2,"title":"递归","slug":"递归","link":"#递归","children":[{"level":3,"title":"调用栈","slug":"调用栈","link":"#调用栈","children":[]},{"level":3,"title":"尾递归","slug":"尾递归","link":"#尾递归","children":[]},{"level":3,"title":"递归树","slug":"递归树","link":"#递归树","children":[]}]},{"level":2,"title":"两者对比","slug":"两者对比","link":"#两者对比","children":[]}],"git":{"createdTime":1715867746000,"updatedTime":1715868418000,"contributors":[{"name":"OnePiece","email":"109900456+NgxuAnGMH@users.noreply.github.com","commits":2}]},"readingTime":{"minutes":9.28,"words":2783},"filePathRelative":"HelloAlgo/第02章 复杂度分析/06-迭代与递归.md","localizedDate":"2024年5月16日","excerpt":"\\n<p>在算法中，重复执行某个任务是很常见的，它与复杂度分析息息相关。因此，在介绍时间复杂度和空间复杂度之前，我们先来了解如何在程序中实现重复执行任务，即两种基本的程序控制结构：迭代、递归。</p>\\n<h2>迭代</h2>\\n<p><u>迭代（iteration）</u>是一种重复执行某个任务的控制结构。在迭代中，程序会在满足一定的条件下重复执行某段代码，直到这个条件不再满足。</p>\\n<h3>for 循环</h3>\\n<p><code>for</code> 循环是最常见的迭代形式之一，<strong>适合在预先知道迭代次数时使用</strong>。</p>\\n<p>以下函数基于 <code>for</code> 循环实现了求和 <span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mo>⋯</mo><mo>+</mo><mi>n</mi></mrow><annotation encoding=\\"application/x-tex\\">1 + 2 + \\\\dots + n</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.7278em;vertical-align:-0.0833em;\\"></span><span class=\\"mord\\">1</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span><span class=\\"mbin\\">+</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span></span><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.7278em;vertical-align:-0.0833em;\\"></span><span class=\\"mord\\">2</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span><span class=\\"mbin\\">+</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span></span><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.6667em;vertical-align:-0.0833em;\\"></span><span class=\\"minner\\">⋯</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span><span class=\\"mbin\\">+</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span></span><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.4306em;\\"></span><span class=\\"mord mathnormal\\">n</span></span></span></span> ，求和结果使用变量 <code>res</code> 记录。需要注意的是，Python 中 <code>range(a, b)</code> 对应的区间是“左闭右开”的，对应的遍历范围为 <span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mi>a</mi><mo separator=\\"true\\">,</mo><mi>a</mi><mo>+</mo><mn>1</mn><mo separator=\\"true\\">,</mo><mo>…</mo><mo separator=\\"true\\">,</mo><mi>b</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\\"application/x-tex\\">a, a + 1, \\\\dots, b-1</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.7778em;vertical-align:-0.1944em;\\"></span><span class=\\"mord mathnormal\\">a</span><span class=\\"mpunct\\">,</span><span class=\\"mspace\\" style=\\"margin-right:0.1667em;\\"></span><span class=\\"mord mathnormal\\">a</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span><span class=\\"mbin\\">+</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span></span><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.8889em;vertical-align:-0.1944em;\\"></span><span class=\\"mord\\">1</span><span class=\\"mpunct\\">,</span><span class=\\"mspace\\" style=\\"margin-right:0.1667em;\\"></span><span class=\\"minner\\">…</span><span class=\\"mspace\\" style=\\"margin-right:0.1667em;\\"></span><span class=\\"mpunct\\">,</span><span class=\\"mspace\\" style=\\"margin-right:0.1667em;\\"></span><span class=\\"mord mathnormal\\">b</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span><span class=\\"mbin\\">−</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span></span><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.6444em;\\"></span><span class=\\"mord\\">1</span></span></span></span> ：</p>"}');export{F as comp,J as data};
