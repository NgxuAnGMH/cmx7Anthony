import{_ as n,c as s,o as a,a as e}from"./app-DC88ES73.js";const t="/assets/640-1715846996962-111-CeHvUXIp.png",p="/assets/640-1715843867160-29-DSXi_GJz.webp",o={},c=e('<h1 id="聊聊c语言和指针的本质" tabindex="-1"><a class="header-anchor" href="#聊聊c语言和指针的本质"><span>聊聊C语言和指针的本质</span></a></h1><p>大家好，今天我们聊一聊C语言的指针。</p><figure><img src="'+t+`" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>来源：https://blog.csdn.net/dog250/article/details/103221309</p><p>很多编程语言都以 “没有指针” 作为自己的优势来宣传，然而，对于C语言，指针却是与生俱来的。</p><p>那么，什么是指针，为什么大家都想避开指针。</p><p>很简单， 指针就是<mark>地址</mark>，当一个地址作为<mark>一个变量</mark>存在时，它就被叫做<mark>指针</mark>，该变量的类型，自然就是<mark>指针类型</mark>。</p><p>指针的作用就是，给出一个指针，<em>取出 该指针指向地址处 的值</em>。为了理解本质，我们从计算机模型说起。</p><p>宏观看来，计算机可以分为两类：</p><ol><li><strong>存储-执行计算机</strong>：这类机器典型的例子就是我们平时使用的计算机，有一个CPU，有一个内存，CPU仅包含运算逻辑，所有的指令和数据都在内存中，内存仅供存储，不包含任何运算组件。</li><li><strong>现场编程计算机</strong>：这类机器的典型例子就是ASCI电路，FPGA这种。直接针对特定的需求构建逻辑电路，然而，由于存在笛卡尔积的问题，不太适合通用计算。</li></ol><p>所以我们只需看平时使用的第一类<strong>存储-执行模型</strong>的计算机工作模式：</p><ul><li>CPU在地址总线上发射一个地址到内存。</li><li>内存把特定地址对应的数据返回到数据总线。</li><li>看起来，通用计算机就是通过指针完成所有工作的。</li></ul><p><u>CPU没有能力直接操作内存里的值</u>，它必须做以下的操作以迂回：</p><ol><li>从特定地址A0取出值V0。</li><li>对V0进行加工运算生成V1。</li><li>将V1存入特定地址A1。</li></ol><p>太初，人们就是按照以上的这么个逻辑编程的，这就是汇编语言：</p><div class="language-assembly line-numbers-mode" data-ext="assembly" data-title="assembly"><pre class="language-assembly"><code>mov    -0x4c(%rbp),%ebx
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然而，这样太麻烦了，C语言随着简单通用的UNIX操作系统而生，下面的语句看起来更加方便：</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
<span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">13</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><u>C语言 直接映射了 CPU的工作方式</u>，而且是用极其简单的方式，这就是<strong>C语言的艺术</strong>。这就是C指针的背景。</p><blockquote><p>这段C代码展示了几个关键概念，包括变量声明、类型转换和指针操作。让我们逐步分析这段代码：</p><ol><li><p><code>int a = 10;</code>：这行代码声明了一个整型变量<code>a</code>，并将其初始化为10。</p></li><li><p><code>char *p = &amp;a;</code>：这行代码声明了一个指向字符的指针<code>p</code>，并将它的地址设置为<code>a</code>的地址。这里发生了隐式类型转换，因为<code>a</code>是一个整数，而<code>p</code>是一个指向字符的指针。在C语言中，整数和字符之间可以进行隐式类型转换，因为字符实际上是整数的一个子集。但是，这种类型转换可能会导致一些问题，因为整数和字符的内存大小可能不同（通常是整数比字符占用更多的字节）。</p></li><li><p><code>*p = 13;</code>：这行代码试图将指针<code>p</code>所指向的内存位置的值设置为13。由于<code>p</code>是一个指向字符的指针，所以这里实际上是在修改<code>a</code>的某个部分。具体来说，由于<code>a</code>是一个整数，它可能占用多个字节（例如，在32位系统中，一个整数可能占用4个字节）。将<code>*p</code>设置为13可能会导致<code>a</code>的低字节被修改为13，而其他字节保持不变。这可能会导致未定义行为，因为直接修改整数的某个部分可能会导致数据损坏。</p></li></ol><p>这段代码展示了一些潜在的问题，包括类型转换和指针操作。在实际编程中，应该避免这种不安全的类型转换和直接修改变量的某个部分。相反，应该使用适当的类型和操作来确保数据的完整性和程序的正确性。</p></blockquote><p>在那个年代，人们还没有渴望计算机帮助完成更复杂的业务逻辑，人们只是希望<em>用一种更加简单的方式抽象出计算机的行为</em>，最终的结晶，就是C语言。于是，我们说，C语言的精华就是指针，指针是C语言的一切。我们可以没有if-else语言，我们可以没有switch-case语句，我们可以不要while，我们不要for，<em>但我们必须有指针</em>。</p><p>是的，我们可以用<strong>指针函数的状态矩阵</strong>代替if-else之类：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>int (*routine)[...]();
...
condition = calc(...);
routine[condition](argv);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们用状态矩阵成功规避了if-else…可以看到，还是用的指针。</p><p>指针是存储-执行模型的计算机工作的<strong>必要条件</strong>！</p><blockquote><p>这段C代码涉及到函数指针数组、可变参数列表和条件语句。让我们逐步分析这段代码：</p><ol><li><p><code>int (*routine)[...]();</code>：这行代码声明了一个名为<code>routine</code>的指针，它指向一个具有可变参数数量的函数数组。<code>int</code>表示数组中每个函数的返回类型是整数。<code>[...]</code>表示数组的长度是可变的，这意味着数组可以包含不同数量的函数。<code>()</code>表示<code>routine</code>是一个指向函数的指针。</p></li><li><p><code>...</code>：这是C语言中的可变参数列表，表示函数可以接受任意数量的参数。在实际编程中，你需要使用宏或特定的函数来处理这些可变参数。</p></li><li><p><code>condition = calc(...);</code>：这行代码调用了一个名为<code>calc</code>的函数，该函数接受可变数量的参数，并返回一个整数值。这个返回值被赋给了一个名为<code>condition</code>的变量。<code>calc</code>函数的具体实现和功能没有在这段代码中给出。</p></li><li><p><code>routine[condition](argv);</code>：这行代码使用<code>condition</code>变量作为索引，从<code>routine</code>数组中选择一个函数，并使用<code>argv</code>作为参数调用该函数。<code>argv</code>是一个参数列表，通常用于传递给C语言中的主函数（<code>main</code>函数）。</p></li></ol><p>这段代码的大致逻辑是：</p><ol><li>调用<code>calc</code>函数，传入一些可变参数，并获取返回值。</li><li>使用返回值作为索引，从<code>routine</code>函数数组中选择一个函数。</li><li>调用选中的函数，传入<code>argv</code>参数列表。</li></ol><p>需要注意的是，这段代码存在一些潜在的问题：</p><ul><li><code>calc</code>函数的具体实现和功能未知，因此无法确定其返回值是否有效作为<code>routine</code>数组的索引。</li><li><code>routine</code>数组的长度和元素的具体类型未知，这可能导致数组越界或其他问题。</li><li>可变参数列表的处理需要使用特定的宏或函数，这段代码中没有给出具体的实现。</li></ul><p>在实际编程中，应该确保正确处理可变参数列表，并确保数组索引和函数调用是安全的。</p></blockquote><p>我们再看存储-执行模型的计算机的工作方式：</p><ul><li>给定一个地址，CPU就可以取出该地址的数据。</li><li>给定一个地址，CPU就可以写入该地址一个值。</li></ul><p>这意味着什么？只要想让CPU正常工作，就必须暴露整个内存地址空间给CPU，否则CPU就是一堆毫无用处的门电路，换句话说， 一切来自内存！操作内存就必然要用指针！其实，<em>C语言就是简化版的汇编语言</em>。最终，C语言接力汇编<em>用指针</em>创造了世界。</p><p>不管怎么样，C语言是面向计算机的编程语言，<strong>而不是面向业务的编程语言</strong>，它映射了计算机的工作方式而不太善于描述业务逻辑，因此，C语言深受黑客，编程手艺人这种计算机本身的爱好者喜爱，却不被业务程序员待见，因为摆弄指针确实太繁琐复杂了，一不小心就会出错。</p><p>存储-执行模型的问题在于，要设计复杂的带外机制防止内存被任意访问，由此而来的就是复杂的分段，分页，访问控制，MMU等机制，当然，这些机制和CPU依靠指针访问内存的工作方式并不冲突。</p><p>把C语言指针用的最绝的应该就是Linux内核的嵌入式链表 struct list_head 了：</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">list_head</span> <span class="token punctuation">{</span><span class="token keyword">struct</span> <span class="token class-name">list_head</span> <span class="token operator">*</span>next<span class="token punctuation">,</span> <span class="token operator">*</span>prev<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>它可以代表一切，它通过C指针完美诠释了OOD/OOP，list_head是世界的基类！</p><p>通过<strong>container_of</strong>宏，list_head可以转换为任意对象：</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/** * container_of - cast a member of a structure out to the containing structure 
* @ptr:        the pointer to the member. 
* @type:       the type of the container struct this is embedded in. 
* @member:     the name of the member within the struct. 
* 
*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">container_of</span><span class="token expression"><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> type<span class="token punctuation">,</span> member<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>                              </span><span class="token punctuation">\\</span>
<span class="token expression"><span class="token keyword">void</span> <span class="token operator">*</span>__mptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>                                   </span><span class="token punctuation">\\</span>
	<span class="token expression"><span class="token function">BUILD_BUG_ON_MSG</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">__same_type</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>type <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>member<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>   </span><span class="token punctuation">\\</span>
    				<span class="token expression"><span class="token operator">!</span><span class="token function">__same_type</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    </span><span class="token punctuation">\\</span>
<span class="token string">&quot;pointer type mismatch in container_of()&quot;</span><span class="token expression"><span class="token punctuation">)</span><span class="token punctuation">;</span>    </span><span class="token punctuation">\\</span>
	<span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span>type <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>__mptr <span class="token operator">-</span> <span class="token function">offsetof</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> member<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span></span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个转换背后的依赖，正是指针：</p><figure><img src="`+p+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>然而，C语言依然对业务编程不友好，前面说了，C语言映射的就是计算机工作方式本身，若想用好C语言，就必须要懂计算机原理，这并不是业务程序员的菜，业务程序员只是编写业务逻辑，并不在乎计算机是如何工作的。</p><p>曾经，计算机还是一群痴迷于技术本身的极客们的玩具，计算机是属于他们的，他们用C编程，用Perl/Python/Bash粘合二进制程序。进入互联网时代，随着越来越复杂的业务逻辑出现，<em>越来越多的职业程序员开始成了多数派，他们开始使用更加业务友好的语言</em>，Java，Go便成功了。</p><p>不能说这些业务编程语言没有指针，<em>只是它们隐藏了指针而已</em>，它们对程序员暴露了更加对业务友好的编程接口和语法，自己在底层处理指针问题，仅此而已。指针是客观存在的，只要你使用的是存储-执行模型的计算机，指针就是一切。</p>',41),i=[c];function l(r,d){return a(),s("div",null,i)}const k=n(o,[["render",l],["__file","Think-in.html.vue"]]),m=JSON.parse('{"path":"/WeChat/GeekReborn/Think-in/Think-in.html","title":"聊聊C语言和指针的本质","lang":"zh-CN","frontmatter":{"date":"2024-05-16T00:00:00.000Z","shortTitle":"02-C语言和指针"},"headers":[],"git":{"createdTime":1715863259000,"updatedTime":1715863259000,"contributors":[{"name":"OnePiece","email":"109900456+NgxuAnGMH@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":8.75,"words":2625},"filePathRelative":"WeChat/GeekReborn/Think-in/Think-in.md","localizedDate":"2024年5月16日","excerpt":"\\n<p>大家好，今天我们聊一聊C语言的指针。</p>\\n<figure><figcaption>图片</figcaption></figure>\\n<p>来源：https://blog.csdn.net/dog250/article/details/103221309</p>\\n<p>很多编程语言都以 “没有指针” 作为自己的优势来宣传，然而，对于C语言，指针却是与生俱来的。</p>\\n<p>那么，什么是指针，为什么大家都想避开指针。</p>\\n<p>很简单， 指针就是<mark>地址</mark>，当一个地址作为<mark>一个变量</mark>存在时，它就被叫做<mark>指针</mark>，该变量的类型，自然就是<mark>指针类型</mark>。</p>"}');export{k as comp,m as data};
