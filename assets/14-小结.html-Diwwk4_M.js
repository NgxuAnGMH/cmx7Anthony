import{_ as l,c as n,o as t,a as e,b as a,d as s}from"./app-NlTosuwL.js";const m={},c=e('<h1 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h1><h2 id="重点回顾" tabindex="-1"><a class="header-anchor" href="#重点回顾"><span>重点回顾</span></a></h2><ul><li>数据结构可以从逻辑结构和物理结构两个角度进行分类。逻辑结构描述了数据元素之间的逻辑关系，而物理结构描述了数据在计算机内存中的存储方式。</li><li>常见的逻辑结构包括线性、树状和网状等。通常我们根据逻辑结构将数据结构分为线性（数组、链表、栈、队列）和非线性（树、图、堆）两种。哈希表的实现可能同时包含线性数据结构和非线性数据结构。</li><li>当程序运行时，数据被存储在计算机内存中。每个内存空间都拥有对应的内存地址，程序通过这些内存地址访问数据。</li><li>物理结构主要分为连续空间存储（数组）和分散空间存储（链表）。所有数据结构都是由数组、链表或两者的组合实现的。</li><li>计算机中的基本数据类型包括整数 <code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code> ，浮点数 <code>float</code>、<code>double</code> ，字符 <code>char</code> 和布尔 <code>bool</code> 。它们的取值范围取决于占用空间大小和表示方式。</li><li>原码、反码和补码是在计算机中编码数字的三种方法，<em>它们之间可以相互转换</em>。整数的原码的最高位是符号位，其余位是数字的值。</li><li>整数在计算机中是以补码的形式存储的。<em>在补码表示下</em>，计算机可以对正数和负数的加法一视同仁，<em>不需要</em>为减法操作单独设计特殊的硬件电路，<em>并且不存在</em>正负零歧义的问题。</li><li>浮点数的编码由 1 位符号位、8 位指数位和 23 位分数位构成。由于存在指数位，因此浮点数的取值范围远大于整数，代价是牺牲了精度。</li><li>ASCII 码是最早出现的英文字符集，长度为 1 字节，共收录 127 个字符。GBK 字符集是常用的中文字符集，共收录两万多个汉字。Unicode 致力于提供一个完整的字符集标准，收录世界上各种语言的字符，从而解决由于字符编码方法不一致而导致的乱码问题。</li><li>UTF-8 是最受欢迎的 Unicode 编码方法，通用性非常好。它是一种变长的编码方法，具有很好的扩展性，有效提升了存储空间的使用效率。 <ul><li>UTF-16 和 UTF-32 是等长的编码方法。</li><li>在编码中文时，UTF-16 占用的空间比 UTF-8 更小。</li><li>Java 和 C# 等编程语言默认使用 UTF-16 编码。</li></ul></li></ul><h2 id="q-a" tabindex="-1"><a class="header-anchor" href="#q-a"><span>Q &amp; A</span></a></h2><p><strong>Q</strong>：为什么哈希表同时包含线性数据结构和非线性数据结构？</p><p>哈希表底层是<em>数组</em>，而为了解决<em>哈希冲突</em>，我们可能会使用“<em>链式地址</em>”（后续“哈希冲突”章节会讲）：数组中每个桶指向一个<em>链表</em>，当链表长度超过一定阈值时，又可能被转化为<em>树</em>（通常为红黑树）。</p><p>从存储的角度来看，哈希表的底层是<em>数组</em>，其中每一个桶槽位可能包含一个值，也可能包含<em>一个链表</em>或<em>一棵树</em>。<u>因此</u>，哈希表可能同时包含线性数据结构（数组、链表）和非线性数据结构（树）。</p><p><strong>Q</strong>：<code>char</code> 类型的长度是 1 字节吗？</p><p><code>char</code> 类型的长度由编程语言采用的编码方法决定。例如，Java、JavaScript、TypeScript、C# 都采用 UTF-16 编码（保存 Unicode 码点），因此 <code>char</code> 类型的长度为 2 字节。</p><p><strong>Q</strong>：基于数组实现的数据结构也称“静态数据结构” 是否有歧义？栈也可以进行出栈和入栈等操作，这些操作都是“动态”的。</p><p>栈确实可以实现动态的数据操作，但数据结构仍然是“静态”（长度不可变）的。尽管基于数组的数据结构可以动态地添加或删除元素，但它们的容量是固定的。如果数据量超出了预分配的大小，就需要创建一个新的更大的数组，并将旧数组的内容复制到新数组中。</p><p><strong>Q</strong>：在构建栈（队列）的时候，未指定它的大小，为什么它们是“静态数据结构”呢？</p><p>在高级编程语言中，我们无须人工指定栈（队列）的初始容量，这个工作由类内部自动完成。例如，Java 的 <code>ArrayList</code> 的初始容量通常为 10。另外，扩容操作也是自动实现的。详见后续的“列表”章节。</p><p><strong>Q</strong>：原码转补码的方法是“先取反后加 1”，那么补码转原码应该是逆运算“先减 1 后取反”，而补码转原码也一样可以通过“先取反后加 1”得到，这是为什么呢？</p>',14),i=a("p",null,[a("strong",null,"A"),s("：这是因为原码和补码的相互转换实际上是计算“补数”的过程。我们先给出补数的定义：假设 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"a"),a("mo",null,"+"),a("mi",null,"b"),a("mo",null,"="),a("mi",null,"c")]),a("annotation",{encoding:"application/x-tex"},"a + b = c")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),a("span",{class:"mord mathnormal"},"a"),a("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),a("span",{class:"mbin"},"+"),a("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6944em"}}),a("span",{class:"mord mathnormal"},"b"),a("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),a("span",{class:"mrel"},"="),a("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.4306em"}}),a("span",{class:"mord mathnormal"},"c")])])]),s(" ，那么我们称 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"a")]),a("annotation",{encoding:"application/x-tex"},"a")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.4306em"}}),a("span",{class:"mord mathnormal"},"a")])])]),s(" 是 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"b")]),a("annotation",{encoding:"application/x-tex"},"b")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6944em"}}),a("span",{class:"mord mathnormal"},"b")])])]),s(" 到 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"c")]),a("annotation",{encoding:"application/x-tex"},"c")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.4306em"}}),a("span",{class:"mord mathnormal"},"c")])])]),s(" 的补数，反之也称 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"b")]),a("annotation",{encoding:"application/x-tex"},"b")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6944em"}}),a("span",{class:"mord mathnormal"},"b")])])]),s(" 是 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"a")]),a("annotation",{encoding:"application/x-tex"},"a")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.4306em"}}),a("span",{class:"mord mathnormal"},"a")])])]),s(" 到 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"c")]),a("annotation",{encoding:"application/x-tex"},"c")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.4306em"}}),a("span",{class:"mord mathnormal"},"c")])])]),s(" 的补数。")],-1),p=a("p",null,[s("给定一个 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"n"),a("mo",null,"="),a("mn",null,"4")]),a("annotation",{encoding:"application/x-tex"},"n = 4")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.4306em"}}),a("span",{class:"mord mathnormal"},"n"),a("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),a("span",{class:"mrel"},"="),a("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"4")])])]),s(" 位长度的二进制数 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mn",null,"0010")]),a("annotation",{encoding:"application/x-tex"},"0010")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"0010")])])]),s(" ，如果将这个数字看作原码（不考虑符号位），那么它的补码需通过“先取反后加 1”得到：")],-1),o=a("p",{class:"katex-block"},[a("span",{class:"katex-display"},[a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[a("semantics",null,[a("mrow",null,[a("mn",null,"0010"),a("mo",null,"→"),a("mn",null,"1101"),a("mo",null,"→"),a("mn",null,"1110")]),a("annotation",{encoding:"application/x-tex"}," 0010 \\rightarrow 1101 \\rightarrow 1110 ")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"0010"),a("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),a("span",{class:"mrel"},"→"),a("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"1101"),a("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),a("span",{class:"mrel"},"→"),a("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"1110")])])])])],-1),h=a("p",null,[s("我们会发现，原码和补码的和是 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mn",null,"0010"),a("mo",null,"+"),a("mn",null,"1110"),a("mo",null,"="),a("mn",null,"10000")]),a("annotation",{encoding:"application/x-tex"},"0010 + 1110 = 10000")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),a("span",{class:"mord"},"0010"),a("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),a("span",{class:"mbin"},"+"),a("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"1110"),a("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),a("span",{class:"mrel"},"="),a("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"10000")])])]),s(" ，也就是说，补码 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mn",null,"1110")]),a("annotation",{encoding:"application/x-tex"},"1110")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"1110")])])]),s(" 是原码 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mn",null,"0010")]),a("annotation",{encoding:"application/x-tex"},"0010")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"0010")])])]),s(" 到 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mn",null,"10000")]),a("annotation",{encoding:"application/x-tex"},"10000")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"10000")])])]),s(" 的“补数”。"),a("strong",null,[s("这意味着上述“先取反后加 1”实际上是计算到 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mn",null,"10000")]),a("annotation",{encoding:"application/x-tex"},"10000")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"10000")])])]),s(" 的补数的过程")]),s("。")],-1),r=a("p",null,[s("那么，补码 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mn",null,"1110")]),a("annotation",{encoding:"application/x-tex"},"1110")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"1110")])])]),s(" 到 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mn",null,"10000")]),a("annotation",{encoding:"application/x-tex"},"10000")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"10000")])])]),s(" 的“补数”是多少呢？我们依然可以用“先取反后加 1”得到它：")],-1),d=a("p",{class:"katex-block"},[a("span",{class:"katex-display"},[a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[a("semantics",null,[a("mrow",null,[a("mn",null,"1110"),a("mo",null,"→"),a("mn",null,"0001"),a("mo",null,"→"),a("mn",null,"0010")]),a("annotation",{encoding:"application/x-tex"}," 1110 \\rightarrow 0001 \\rightarrow 0010 ")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"1110"),a("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),a("span",{class:"mrel"},"→"),a("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"0001"),a("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),a("span",{class:"mrel"},"→"),a("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"0010")])])])])],-1),u=a("p",null,[s("换句话说，原码和补码互为对方到 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mn",null,"10000")]),a("annotation",{encoding:"application/x-tex"},"10000")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"10000")])])]),s(" 的“补数”，因此“原码转补码”和“补码转原码”可以用相同的操作（先取反后加 1 ）实现。")],-1),g=a("p",null,[s("当然，我们也可以用逆运算来求补码 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mn",null,"1110")]),a("annotation",{encoding:"application/x-tex"},"1110")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"1110")])])]),s(" 的原码，即“先减 1 后取反”：")],-1),x=a("p",{class:"katex-block"},[a("span",{class:"katex-display"},[a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[a("semantics",null,[a("mrow",null,[a("mn",null,"1110"),a("mo",null,"→"),a("mn",null,"1101"),a("mo",null,"→"),a("mn",null,"0010")]),a("annotation",{encoding:"application/x-tex"}," 1110 \\rightarrow 1101 \\rightarrow 0010 ")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"1110"),a("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),a("span",{class:"mrel"},"→"),a("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"1101"),a("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),a("span",{class:"mrel"},"→"),a("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"0010")])])])])],-1),w=a("p",null,[s("总结来看，“先取反后加 1”和“先减 1 后取反”这两种运算都是在计算到 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mn",null,"10000")]),a("annotation",{encoding:"application/x-tex"},"10000")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"10000")])])]),s(" 的补数，它们是等价的。")],-1),k=a("p",null,[s("本质上看，“取反”操作实际上是求到 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mn",null,"1111")]),a("annotation",{encoding:"application/x-tex"},"1111")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"1111")])])]),s(" 的补数（因为恒有 "),a("code",null,"原码 + 反码 = 1111"),s("）；而在反码基础上再加 1 得到的补码，就是到 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mn",null,"10000")]),a("annotation",{encoding:"application/x-tex"},"10000")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"10000")])])]),s(" 的补数。")],-1),M=a("p",null,[s("上述 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"n"),a("mo",null,"="),a("mn",null,"4")]),a("annotation",{encoding:"application/x-tex"},"n = 4")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.4306em"}}),a("span",{class:"mord mathnormal"},"n"),a("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),a("span",{class:"mrel"},"="),a("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"4")])])]),s(" 为例，其可推广至任意位数的二进制数。")],-1),y=[c,i,p,o,h,r,d,u,g,x,w,k,M];function b(_,L){return t(),n("div",null,y)}const U=l(m,[["render",b],["__file","14-小结.html.vue"]]),A=JSON.parse('{"path":"/HelloAlgo/%E7%AC%AC03%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/14-%E5%B0%8F%E7%BB%93.html","title":"小结","lang":"zh-CN","frontmatter":{"date":"2024-05-16T00:00:00.000Z","shortTitle":"14-小结"},"headers":[{"level":2,"title":"重点回顾","slug":"重点回顾","link":"#重点回顾","children":[]},{"level":2,"title":"Q & A","slug":"q-a","link":"#q-a","children":[]}],"git":{"createdTime":1715869557000,"updatedTime":1715869557000,"contributors":[{"name":"OnePiece","email":"109900456+NgxuAnGMH@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":5.47,"words":1640},"filePathRelative":"HelloAlgo/第03章 数据结构/14-小结.md","localizedDate":"2024年5月16日","excerpt":"\\n<h2>重点回顾</h2>\\n<ul>\\n<li>数据结构可以从逻辑结构和物理结构两个角度进行分类。逻辑结构描述了数据元素之间的逻辑关系，而物理结构描述了数据在计算机内存中的存储方式。</li>\\n<li>常见的逻辑结构包括线性、树状和网状等。通常我们根据逻辑结构将数据结构分为线性（数组、链表、栈、队列）和非线性（树、图、堆）两种。哈希表的实现可能同时包含线性数据结构和非线性数据结构。</li>\\n<li>当程序运行时，数据被存储在计算机内存中。每个内存空间都拥有对应的内存地址，程序通过这些内存地址访问数据。</li>\\n<li>物理结构主要分为连续空间存储（数组）和分散空间存储（链表）。所有数据结构都是由数组、链表或两者的组合实现的。</li>\\n<li>计算机中的基本数据类型包括整数 <code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code> ，浮点数 <code>float</code>、<code>double</code> ，字符 <code>char</code> 和布尔 <code>bool</code> 。它们的取值范围取决于占用空间大小和表示方式。</li>\\n<li>原码、反码和补码是在计算机中编码数字的三种方法，<em>它们之间可以相互转换</em>。整数的原码的最高位是符号位，其余位是数字的值。</li>\\n<li>整数在计算机中是以补码的形式存储的。<em>在补码表示下</em>，计算机可以对正数和负数的加法一视同仁，<em>不需要</em>为减法操作单独设计特殊的硬件电路，<em>并且不存在</em>正负零歧义的问题。</li>\\n<li>浮点数的编码由 1 位符号位、8 位指数位和 23 位分数位构成。由于存在指数位，因此浮点数的取值范围远大于整数，代价是牺牲了精度。</li>\\n<li>ASCII 码是最早出现的英文字符集，长度为 1 字节，共收录 127 个字符。GBK 字符集是常用的中文字符集，共收录两万多个汉字。Unicode 致力于提供一个完整的字符集标准，收录世界上各种语言的字符，从而解决由于字符编码方法不一致而导致的乱码问题。</li>\\n<li>UTF-8 是最受欢迎的 Unicode 编码方法，通用性非常好。它是一种变长的编码方法，具有很好的扩展性，有效提升了存储空间的使用效率。\\n<ul>\\n<li>UTF-16 和 UTF-32 是等长的编码方法。</li>\\n<li>在编码中文时，UTF-16 占用的空间比 UTF-8 更小。</li>\\n<li>Java 和 C# 等编程语言默认使用 UTF-16 编码。</li>\\n</ul>\\n</li>\\n</ul>"}');export{U as comp,A as data};
