import{_ as t,c as e,o as l,a as s,b as a,d as n}from"./app-DC88ES73.js";const r="/assets/array_definition-CVs72AXV.png",i="/assets/array_memory_location_calculation-UiTheQjm.png",o="/assets/array_insert_element-CcFqGZR2.png",c="/assets/array_remove_element-CHMEhhbJ.png",p={},m=s('<h1 id="数组" tabindex="-1"><a class="header-anchor" href="#数组"><span>数组</span></a></h1><p><u>数组（array）</u>是一种线性数据结构，其将<em>相同类型的元素</em>存储在连续的内存空间中。我们将元素在数组中的位置称为该元素的<u>索引（index）</u>。下图展示了数组的主要概念和存储方式。</p><figure><img src="'+r+'" alt="数组定义与存储方式" tabindex="0" loading="lazy"><figcaption>数组定义与存储方式</figcaption></figure><h2 id="数组常用操作" tabindex="-1"><a class="header-anchor" href="#数组常用操作"><span>数组常用操作</span></a></h2><h3 id="初始化数组" tabindex="-1"><a class="header-anchor" href="#初始化数组"><span>初始化数组</span></a></h3>',5),u=a("p",null,[n("我们可以根据需求选用数组的两种初始化方式：无初始值、给定初始值。在未指定初始值的情况下，大多数编程语言会将数组元素初始化为 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mn",null,"0")]),a("annotation",{encoding:"application/x-tex"},"0")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"0")])])]),n(" ：")],-1),d=s('<p>=== &quot;Python&quot;</p><pre><code>```python title=&quot;array.py&quot;\n# 初始化数组\narr: list[int] = [0] * 5  # [ 0, 0, 0, 0, 0 ]\nnums: list[int] = [1, 3, 2, 5, 4]  \n```\n</code></pre><p>=== &quot;C++&quot;</p><pre><code>```cpp title=&quot;array.cpp&quot;\n/* 初始化数组 */\n// 存储在栈上\nint arr[5];\nint nums[5] = { 1, 3, 2, 5, 4 };\n// 存储在堆上（需要手动释放空间）\nint* arr1 = new int[5];\nint* nums1 = new int[5] { 1, 3, 2, 5, 4 };\n```\n</code></pre><p>=== &quot;Java&quot;</p><pre><code>```java title=&quot;array.java&quot;\n/* 初始化数组 */\nint[] arr = new int[5]; // { 0, 0, 0, 0, 0 }\nint[] nums = { 1, 3, 2, 5, 4 };\n```\n</code></pre><p>=== &quot;C#&quot;</p><pre><code>```csharp title=&quot;array.cs&quot;\n/* 初始化数组 */\nint[] arr = new int[5]; // [ 0, 0, 0, 0, 0 ]\nint[] nums = [1, 3, 2, 5, 4];\n```\n</code></pre><p>=== &quot;Go&quot;</p><pre><code>```go title=&quot;array.go&quot;\n/* 初始化数组 */\nvar arr [5]int\n// 在 Go 中，指定长度时（[5]int）为数组，不指定长度时（[]int）为切片\n// 由于 Go 的数组被设计为在编译期确定长度，因此只能使用常量来指定长度\n// 为了方便实现扩容 extend() 方法，以下将切片（Slice）看作数组（Array）\nnums := []int{1, 3, 2, 5, 4}\n```\n</code></pre><p>=== &quot;Swift&quot;</p><pre><code>```swift title=&quot;array.swift&quot;\n/* 初始化数组 */\nlet arr = Array(repeating: 0, count: 5) // [0, 0, 0, 0, 0]\nlet nums = [1, 3, 2, 5, 4]\n```\n</code></pre><p>=== &quot;JS&quot;</p><pre><code>```javascript title=&quot;array.js&quot;\n/* 初始化数组 */\nvar arr = new Array(5).fill(0);\nvar nums = [1, 3, 2, 5, 4];\n```\n</code></pre><p>=== &quot;TS&quot;</p><pre><code>```typescript title=&quot;array.ts&quot;\n/* 初始化数组 */\nlet arr: number[] = new Array(5).fill(0);\nlet nums: number[] = [1, 3, 2, 5, 4];\n```\n</code></pre><p>=== &quot;Dart&quot;</p><pre><code>```dart title=&quot;array.dart&quot;\n/* 初始化数组 */\nList&lt;int&gt; arr = List.filled(5, 0); // [0, 0, 0, 0, 0]\nList&lt;int&gt; nums = [1, 3, 2, 5, 4];\n```\n</code></pre><p>=== &quot;Rust&quot;</p><pre><code>```rust title=&quot;array.rs&quot;\n/* 初始化数组 */\nlet arr: [i32; 5] = [0; 5]; // [0, 0, 0, 0, 0]\nlet slice: &amp;[i32] = &amp;[0; 5];\n// 在 Rust 中，指定长度时（[i32; 5]）为数组，不指定长度时（&amp;[i32]）为切片\n// 由于 Rust 的数组被设计为在编译期确定长度，因此只能使用常量来指定长度\n// Vector 是 Rust 一般情况下用作动态数组的类型\n// 为了方便实现扩容 extend() 方法，以下将 vector 看作数组（array）\nlet nums: Vec&lt;i32&gt; = vec![1, 3, 2, 5, 4];\n```\n</code></pre><p>=== &quot;C&quot;</p><pre><code>```c title=&quot;array.c&quot;\n/* 初始化数组 */\nint arr[5] = { 0 }; // { 0, 0, 0, 0, 0 }\nint nums[5] = { 1, 3, 2, 5, 4 };\n```\n</code></pre><p>=== &quot;Kotlin&quot;</p><pre><code>```kotlin title=&quot;array.kt&quot;\n/* 初始化数组 */\nvar arr = IntArray(5) // { 0, 0, 0, 0, 0 }\nvar nums = intArrayOf(1, 3, 2, 5, 4)\n```\n</code></pre><p>=== &quot;Ruby&quot;</p><pre><code>```ruby title=&quot;array.rb&quot;\n# 初始化数组\narr = Array.new(5, 0)\nnums = [1, 3, 2, 5, 4]\n```\n</code></pre><p>=== &quot;Zig&quot;</p><pre><code>```zig title=&quot;array.zig&quot;\n// 初始化数组\nvar arr = [_]i32{0} ** 5; // { 0, 0, 0, 0, 0 }\nvar nums = [_]i32{ 1, 3, 2, 5, 4 };\n```\n</code></pre><p>??? pythontutor &quot;可视化运行&quot;</p><pre><code>https://pythontutor.com/render.html#code=%23%20%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84%0Aarr%20%3D%20%5B0%5D%20*%205%20%20%23%20%5B%200,%200,%200,%200,%200%20%5D%0Anums%20%3D%20%5B1,%203,%202,%205,%204%5D&amp;cumulative=false&amp;curInstr=0&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=311&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false\n</code></pre><h3 id="访问元素" tabindex="-1"><a class="header-anchor" href="#访问元素"><span>访问元素</span></a></h3><p>数组元素被存储在连续的内存空间中，这意味着计算数组元素的内存地址非常容易。给定数组内存地址（首元素内存地址）和某个元素的索引，我们可以使用下图所示的公式计算得到该元素的内存地址，从而直接访问该元素。</p><figure><img src="'+i+'" alt="数组元素的内存地址计算" tabindex="0" loading="lazy"><figcaption>数组元素的内存地址计算</figcaption></figure>',33),h=a("p",null,[n("观察上图，我们发现数组首个元素的索引为 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mn",null,"0")]),a("annotation",{encoding:"application/x-tex"},"0")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"0")])])]),n(" ，这似乎有些反直觉，因为从 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mn",null,"1")]),a("annotation",{encoding:"application/x-tex"},"1")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"1")])])]),n(" 开始计数会更自然。但从地址计算公式的角度看，"),a("strong",null,"索引本质上是内存地址的偏移量"),n("。首个元素的地址偏移量是 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mn",null,"0")]),a("annotation",{encoding:"application/x-tex"},"0")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"0")])])]),n(" ，因此它的索引为 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mn",null,"0")]),a("annotation",{encoding:"application/x-tex"},"0")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"0")])])]),n(" 是合理的。")],-1),g=a("p",null,[n("在数组中访问元素非常高效，我们可以在 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"O"),a("mo",{stretchy:"false"},"("),a("mn",null,"1"),a("mo",{stretchy:"false"},")")]),a("annotation",{encoding:"application/x-tex"},"O(1)")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),a("span",{class:"mopen"},"("),a("span",{class:"mord"},"1"),a("span",{class:"mclose"},")")])])]),n(" 时间内随机访问数组中的任意一个元素。")],-1),x=s(`<div class="language-src line-numbers-mode" data-ext="src" data-title="src"><pre class="language-src"><code>[file]{array}-[class]{}-[func]{random_access}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="插入元素" tabindex="-1"><a class="header-anchor" href="#插入元素"><span>插入元素</span></a></h3><p>数组元素在内存中是“紧挨着的”，它们之间没有空间再存放任何数据。如下图所示，如果想在数组中间插入一个元素，则需要将该元素之后的所有元素都向后移动一位，之后再把元素赋值给该索引。</p><figure><img src="`+o+`" alt="数组插入元素示例" tabindex="0" loading="lazy"><figcaption>数组插入元素示例</figcaption></figure><p>值得注意的是，由于数组的长度是固定的，因此插入一个元素必定会导致<u>数组尾部元素“丢失”</u>。我们将这个问题的解决方案留在“列表”章节中讨论。</p><div class="language-src line-numbers-mode" data-ext="src" data-title="src"><pre class="language-src"><code>[file]{array}-[class]{}-[func]{insert}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="删除元素" tabindex="-1"><a class="header-anchor" href="#删除元素"><span>删除元素</span></a></h3>`,7),w=a("p",null,[n("同理，如下图所示，若想删除索引 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"i")]),a("annotation",{encoding:"application/x-tex"},"i")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6595em"}}),a("span",{class:"mord mathnormal"},"i")])])]),n(" 处的元素，则需要把索引 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"i")]),a("annotation",{encoding:"application/x-tex"},"i")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6595em"}}),a("span",{class:"mord mathnormal"},"i")])])]),n(" 之后的元素都向前移动一位。")],-1),y=s('<figure><img src="'+c+`" alt="数组删除元素示例" tabindex="0" loading="lazy"><figcaption>数组删除元素示例</figcaption></figure><p>请注意，删除元素完成后，原先末尾的元素变得“无意义”了，所以我们<em>无须特意去修改它</em>。</p><div class="language-src line-numbers-mode" data-ext="src" data-title="src"><pre class="language-src"><code>[file]{array}-[class]{}-[func]{remove}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>总的来看，数组的插入与删除操作有以下缺点。</p>`,4),v=a("ul",null,[a("li",null,[a("strong",null,"时间复杂度高"),n("：数组的插入和删除的平均时间复杂度均为 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"O"),a("mo",{stretchy:"false"},"("),a("mi",null,"n"),a("mo",{stretchy:"false"},")")]),a("annotation",{encoding:"application/x-tex"},"O(n)")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),a("span",{class:"mopen"},"("),a("span",{class:"mord mathnormal"},"n"),a("span",{class:"mclose"},")")])])]),n(" ，其中 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"n")]),a("annotation",{encoding:"application/x-tex"},"n")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.4306em"}}),a("span",{class:"mord mathnormal"},"n")])])]),n(" 为数组长度。")]),a("li",null,[a("strong",null,"丢失元素"),n("：由于数组的长度不可变，因此在插入元素后，超出数组长度范围的元素会丢失。")]),a("li",null,[a("strong",null,"内存浪费"),n("：我们可以初始化一个比较长的数组，只用前面一部分，这样在插入数据时，丢失的末尾元素都是“无意义”的，但这样做会造成部分内存空间浪费。")])],-1),f=s(`<h3 id="遍历数组" tabindex="-1"><a class="header-anchor" href="#遍历数组"><span>遍历数组</span></a></h3><p>在大多数编程语言中，我们既可以通过索引遍历数组，也可以直接遍历获取数组中的每个元素：</p><div class="language-src line-numbers-mode" data-ext="src" data-title="src"><pre class="language-src"><code>[file]{array}-[class]{}-[func]{traverse}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="查找元素" tabindex="-1"><a class="header-anchor" href="#查找元素"><span>查找元素</span></a></h3><p>在数组中查找指定元素需要遍历数组，每轮判断元素值是否匹配，若匹配则输出对应索引。</p><p>因为数组是线性数据结构，所以上述查找操作被称为“线性查找”。</p><div class="language-src line-numbers-mode" data-ext="src" data-title="src"><pre class="language-src"><code>[file]{array}-[class]{}-[func]{find}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="扩容数组" tabindex="-1"><a class="header-anchor" href="#扩容数组"><span>扩容数组</span></a></h3><p>在复杂的系统环境中，程序难以保证数组之后的内存空间是可用的，从而无法安全地扩展数组容量。因此在大多数编程语言中，<strong>数组的长度是不可变的</strong>。</p>`,9),_=a("p",null,[n("如果我们希望扩容数组，则需重新建立一个更大的数组，然后把原数组元素依次复制到新数组。这是一个 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"O"),a("mo",{stretchy:"false"},"("),a("mi",null,"n"),a("mo",{stretchy:"false"},")")]),a("annotation",{encoding:"application/x-tex"},"O(n)")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),a("span",{class:"mopen"},"("),a("span",{class:"mord mathnormal"},"n"),a("span",{class:"mclose"},")")])])]),n(" 的操作，在数组很大的情况下非常耗时。代码如下所示：")],-1),q=s(`<div class="language-src line-numbers-mode" data-ext="src" data-title="src"><pre class="language-src"><code>[file]{array}-[class]{}-[func]{extend}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="数组的优点与局限性" tabindex="-1"><a class="header-anchor" href="#数组的优点与局限性"><span>数组的优点与局限性</span></a></h2><p>数组存储在连续的内存空间内，且元素类型相同。这种做法包含丰富的先验信息，系统可以利用这些信息来优化数据结构的操作效率。</p>`,3),b=a("ul",null,[a("li",null,[a("strong",null,"空间效率高"),n("：数组为数据分配了连续的内存块，无须额外的结构开销。")]),a("li",null,[a("strong",null,"支持随机访问"),n("：数组允许在 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"O"),a("mo",{stretchy:"false"},"("),a("mn",null,"1"),a("mo",{stretchy:"false"},")")]),a("annotation",{encoding:"application/x-tex"},"O(1)")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),a("span",{class:"mopen"},"("),a("span",{class:"mord"},"1"),a("span",{class:"mclose"},")")])])]),n(" 时间内访问任何元素。")]),a("li",null,[a("strong",null,"缓存局部性"),n("：当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度。")])],-1),k=s('<p>连续空间存储是一把双刃剑，其存在以下局限性。</p><ul><li><strong>插入与删除效率低</strong>：当数组中元素较多时，插入与删除操作需要移动大量的元素。</li><li><strong>长度不可变</strong>：数组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组，开销很大。</li><li><strong>空间浪费</strong>：如果数组分配的大小超过实际所需，那么多余的空间就被浪费了。</li></ul><h2 id="数组典型应用" tabindex="-1"><a class="header-anchor" href="#数组典型应用"><span>数组典型应用</span></a></h2><p>数组是一种基础且常见的数据结构，既频繁应用在各类算法之中，也可用于实现各种复杂数据结构。</p><ul><li><strong>随机访问</strong>：如果我们想随机抽取一些样本，那么可以用数组存储，并生成一个随机序列，根据索引实现随机抽样。</li><li><strong>排序和搜索</strong>：数组是排序和搜索算法最常用的数据结构。快速排序、归并排序、二分查找等都主要在数组上进行。</li><li><strong>查找表</strong>：当需要快速查找一个元素或其对应关系时，可以使用数组作为查找表。假如我们想实现字符到 ASCII 码的映射，则可以将字符的 ASCII 码值作为索引，对应的元素存放在数组中的对应位置。</li><li><strong>机器学习</strong>：神经网络中大量使用了向量、矩阵、张量之间的线性代数运算，这些数据都是以数组的形式构建的。数组是神经网络编程中最常使用的数据结构。</li><li><strong>数据结构实现</strong>：数组可以用于实现栈、队列、哈希表、堆、图等数据结构。例如，图的邻接矩阵表示实际上是一个二维数组。</li></ul>',5),M=[m,u,d,h,g,x,w,y,v,f,_,q,b,k];function A(B,E){return l(),e("div",null,M)}const O=t(p,[["render",A],["__file","-15 数组.html.vue"]]),C=JSON.parse('{"path":"/HelloAlgo/%E7%AC%AC04%E7%AB%A0%20%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/-15%20%E6%95%B0%E7%BB%84.html","title":"数组","lang":"zh-CN","frontmatter":{"date":"2024-05-16T00:00:00.000Z","shortTitle":"-15 数组"},"headers":[{"level":2,"title":"数组常用操作","slug":"数组常用操作","link":"#数组常用操作","children":[{"level":3,"title":"初始化数组","slug":"初始化数组","link":"#初始化数组","children":[]},{"level":3,"title":"访问元素","slug":"访问元素","link":"#访问元素","children":[]},{"level":3,"title":"插入元素","slug":"插入元素","link":"#插入元素","children":[]},{"level":3,"title":"删除元素","slug":"删除元素","link":"#删除元素","children":[]},{"level":3,"title":"遍历数组","slug":"遍历数组","link":"#遍历数组","children":[]},{"level":3,"title":"查找元素","slug":"查找元素","link":"#查找元素","children":[]},{"level":3,"title":"扩容数组","slug":"扩容数组","link":"#扩容数组","children":[]}]},{"level":2,"title":"数组的优点与局限性","slug":"数组的优点与局限性","link":"#数组的优点与局限性","children":[]},{"level":2,"title":"数组典型应用","slug":"数组典型应用","link":"#数组典型应用","children":[]}],"git":{"createdTime":1715872372000,"updatedTime":1715872372000,"contributors":[{"name":"OnePiece","email":"109900456+NgxuAnGMH@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":7.84,"words":2352},"filePathRelative":"HelloAlgo/第04章 数组与链表/-15 数组.md","localizedDate":"2024年5月16日","excerpt":"\\n<p><u>数组（array）</u>是一种线性数据结构，其将<em>相同类型的元素</em>存储在连续的内存空间中。我们将元素在数组中的位置称为该元素的<u>索引（index）</u>。下图展示了数组的主要概念和存储方式。</p>\\n<figure><figcaption>数组定义与存储方式</figcaption></figure>\\n<h2>数组常用操作</h2>\\n<h3>初始化数组</h3>\\n<p>我们可以根据需求选用数组的两种初始化方式：无初始值、给定初始值。在未指定初始值的情况下，大多数编程语言会将数组元素初始化为 <span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\\"application/x-tex\\">0</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.6444em;\\"></span><span class=\\"mord\\">0</span></span></span></span> ：</p>"}');export{O as comp,C as data};
